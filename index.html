<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>交互式地图</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            user-select: none;
            background-color: #000;
            font-family: 'Microsoft YaHei', sans-serif;
        }

        #map-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #map {
            position: absolute;
            transform-origin: 0 0;
            cursor: grab;
            transition: transform 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        #map.grabbing {
            cursor: grabbing;
        }

        .icon {
            position: absolute;
            width: 100px;
            /* height: 40px; */
            transform-origin: center;
            cursor: pointer;
            z-index: 10;
        }

        .icon-boss {
            width: 120px;
        }

        .icon-safe-box {
            width: 150px;
        }

        .icon-evacuate {
            width: 200px;
        }

        /* Boss图标半透明红色圆圈效果 */
        .icon-boss div::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: 800px;
            border-radius: 50%;
            border: 10px dashed rgba(255, 0, 0, 0.6);
            background-color: rgba(255, 0, 0, 0.15);
            z-index: -1;
        }

        /* 图标选中效果 - 仅显示四个角的绿色框 */
        .icon.selected::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            height: 135%;
            aspect-ratio: 1 / 1;
            background-color: rgba(155, 227, 128, 0.3);
            border-color: rgba(155, 227, 128, 1);
            border-width: 8px;
            border-style: solid;
            z-index: -1;
        }

        .zoom-control {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            padding: 10px 5px;
            z-index: 100;
            align-items: center;
        }

        .zoom-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            font-weight: bold;
            margin: 5px 0;
            cursor: pointer;
            user-select: none;
        }

        .zoom-btn:hover {
            background-color: rgba(255, 255, 255, 1);
        }
        
        .zoom-slider-container {
            height: 100px;
            width: 30px;
            margin: 10px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .zoom-slider-track {
            height: 100%;
            width: 4px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            position: relative;
        }
        
        .zoom-slider-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 2px;
        }
        
        .zoom-slider-thumb {
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: white;
            border-radius: 50%;
            left: 50%;
            transform: translateX(-50%);
            cursor: pointer;
        }

        .popup {
            position: fixed;
            left: 20px;
            top: 20px;
            width: 300px;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            z-index: 200;
            display: none;
        }

        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #444;
        }

        .popup-title {
            font-size: 18px;
            font-weight: bold;
        }

        .popup-close {
            cursor: pointer;
            font-size: 20px;
        }

        .popup-content {
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        /* 移动端横屏提示 */
        #orientation-message {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: #fff;
            z-index: 1000;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 24px;
            padding: 20px;
        }

        /* 媒体查询，针对移动设备 */
        @media (max-width: 768px) and (orientation: portrait) {
            #orientation-message {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div id="map-container">
        <div id="map">
            <!-- 地图图片作为背景 -->
            <img src="assets/img/map/文萃.png" alt="地图" id="map-img">
            
            <!-- 图标将通过JavaScript动态添加 -->
        </div>
    </div>

    <!-- 缩放控制 -->
    <div class="zoom-control">
        <div class="zoom-btn" id="zoom-in">+</div>
        <div class="zoom-slider-container">
            <div class="zoom-slider-track">
                <div class="zoom-slider-fill" id="zoom-slider-fill"></div>
            </div>
            <div class="zoom-slider-thumb" id="zoom-slider-thumb"></div>
        </div>
        <div class="zoom-btn" id="zoom-out">-</div>
    </div>

    <!-- 弹出窗口 -->
    <div class="popup" id="info-popup">
        <div class="popup-header">
            <div class="popup-title" id="popup-title">标题</div>
            <div class="popup-close" id="popup-close">×</div>
        </div>
        <div class="popup-content" id="popup-content">
            内容将在这里显示
        </div>
    </div>

    <!-- 移动端横屏提示 -->
    <div id="orientation-message">
        请将设备横屏以获得最佳体验
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 获取DOM元素
            const mapContainer = document.getElementById('map-container');
            const map = document.getElementById('map');
            const mapImg = document.getElementById('map-img');
            const zoomIn = document.getElementById('zoom-in');
            const zoomOut = document.getElementById('zoom-out');
            const popup = document.getElementById('info-popup');
            const popupTitle = document.getElementById('popup-title');
            const popupContent = document.getElementById('popup-content');
            const popupClose = document.getElementById('popup-close');

            // 地图状态
            let mapState = {
                scale: 1,
                minScale: 1,  // 最小缩放比例
                maxScale: 2,  // 最大缩放比例
                translateX: 0,
                translateY: 0,
                lastPosX: 0,
                lastPosY: 0,
                isDragging: false,
                backgroundColor: '#000' // 默认背景色
            };

            // 图标数据 - 示例数据，可以根据需要修改
            const iconData = [
                { x: 0.1112, y: 0.3, icon: 'assets/img/icon/boss.png', class: 'icon-boss', title: '首领', content: '这是一个首领点，可以在这里挑战强大的敌人。' },
                { x: 0.1135, y: 0.6, icon: 'assets/img/icon/task.png', class: 'icon-task', title: '任务', content: '这里有一个任务等待完成。' },
                { x: 0.8, y: 0.2, icon: 'assets/img/icon/safe_box.png', class: 'icon-safe-box', title: '保险箱', content: '这里有一个保险箱，可能包含有价值的物品。' },
                { x: 0.3, y: 0.7, icon: 'assets/img/icon/evacuate.png', class: 'icon-evacuate', title: '撤离点', content: '这是一个撤离点，可以从这里离开地图。' },
                { x: 0.7, y: 0.5, icon: 'assets/img/icon/high_value_task.png', class: 'icon-task', title: '高价值任务', content: '这是一个高价值任务，完成后可获得丰厚奖励。' }
            ];

            // 等待图片加载完成
            mapImg.onload = function() {
                initMap();
                createIcons();
                setupEventListeners();
            };

            // 初始化地图
            function initMap() {
                // 确保地图完全显示在屏幕上
                const containerWidth = mapContainer.clientWidth;
                const containerHeight = mapContainer.clientHeight;
                const imgWidth = mapImg.naturalWidth;
                const imgHeight = mapImg.naturalHeight;

                // 计算初始缩放比例，确保地图完全显示
                const scaleX = containerWidth / imgWidth;
                const scaleY = containerHeight / imgHeight;
                mapState.minScale = Math.min(scaleX, scaleY); // 使用较小的比例确保地图完全显示
                mapState.scale = mapState.minScale;

                // 计算背景色（从地图边缘提取）
                calculateBackgroundColor();

                // 居中显示地图
                updateMapTransform();
                
                // 更新滑动条
                updateZoomSlider();
            }
            
            // 计算背景色
            function calculateBackgroundColor() {
                // 这里可以实现从地图边缘提取颜色的逻辑
                // 简单起见，我们使用一个固定的深色
                mapState.backgroundColor = '#1a1a1a';
                document.body.style.backgroundColor = mapState.backgroundColor;
            }

            // 创建图标
            function createIcons() {
                iconData.forEach((data, index) => {
                    // 创建包裹元素用于实现四角边框效果
                    const iconWrapper = document.createElement('div');
                    iconWrapper.className = 'icon';
                    iconWrapper.dataset.index = index;
                    iconWrapper.alt = data.title;
                    data.class ? iconWrapper.classList.add(data.class) : null;
                    
                    // 创建内部span元素用于实现四角边框
                    const cornerSpan = document.createElement('span');
                    const cornerDiv = document.createElement('div');
                    
                    // 创建图标元素
                    const icon = document.createElement('img');
                    icon.src = data.icon;
                    icon.style.width = '100%';
                    
                    // 组装DOM结构
                    iconWrapper.appendChild(icon);
                    iconWrapper.appendChild(cornerSpan);
                    iconWrapper.appendChild(cornerDiv);
                    
                    // 设置图标位置
                    updateIconPosition(iconWrapper, data);
                    
                    // 只有非boss图标才添加点击事件和选中状态
                    if (!data.class || !data.class.includes('boss')) {
                        iconWrapper.addEventListener('click', function(e) {
                            e.stopPropagation();
                            
                            // 移除其他图标的选中状态
                            document.querySelectorAll('.icon').forEach(icon => {
                                icon.classList.remove('selected');
                            });
                            
                            // 添加当前图标的选中状态
                            this.classList.add('selected');
                            
                            showPopup(data);
                        });
                    } else {
                        // boss图标不可点击，添加样式标识
                        iconWrapper.style.pointerEvents = 'none';
                    }
                    
                    map.appendChild(iconWrapper);
                });
            }

            // 更新图标位置
            function updateIconPosition(icon, data) {
                const imgWidth = mapImg.naturalWidth;
                const imgHeight = mapImg.naturalHeight;
                
                // 根据相对位置计算绝对位置
                const x = data.x * imgWidth;
                const y = data.y * imgHeight;
                
                icon.style.left = `${x - 20}px`; // 20是图标宽度的一半
                icon.style.top = `${y - 20}px`;  // 20是图标高度的一半
            }

            // 更新所有图标位置
            function updateAllIconPositions() {
                const icons = document.querySelectorAll('.icon');
                icons.forEach(icon => {
                    const index = parseInt(icon.dataset.index);
                    updateIconPosition(icon, iconData[index]);
                });
            }

            // 显示弹窗
            function showPopup(data) {
                popupTitle.textContent = data.title;
                popupContent.textContent = data.content;
                popup.style.display = 'block';
            }

            // 隐藏弹窗
            function hidePopup() {
                popup.style.display = 'none';
                
                // 隐藏弹窗时移除所有图标的选中状态
                document.querySelectorAll('.icon').forEach(icon => {
                    icon.classList.remove('selected');
                });
            }

            // 更新地图变换
            function updateMapTransform(isDragging = false) {
                // 计算边界限制
                const containerWidth = mapContainer.clientWidth;
                const containerHeight = mapContainer.clientHeight;
                const imgWidth = mapImg.naturalWidth * mapState.scale;
                const imgHeight = mapImg.naturalHeight * mapState.scale;
                
                // 确保地图不会移出视图
                if (imgWidth > containerWidth) {
                    mapState.translateX = Math.min(0, Math.max(containerWidth - imgWidth, mapState.translateX));
                } else {
                    mapState.translateX = (containerWidth - imgWidth) / 2;
                }
                
                if (imgHeight > containerHeight) {
                    mapState.translateY = Math.min(0, Math.max(containerHeight - imgHeight, mapState.translateY));
                } else {
                    mapState.translateY = (containerHeight - imgHeight) / 2;
                }
                
                // 在拖动时禁用过渡效果，缩放时启用
                if (isDragging) {
                    map.style.transition = 'none';
                } else {
                    map.style.transition = 'transform 0.2s cubic-bezier(0.25, 0.1, 0.25, 1)';
                }
                
                // 应用变换，使用transform的will-change属性和硬件加速来减少停顿感
                map.style.transform = `translate3d(${mapState.translateX}px, ${mapState.translateY}px, 0) scale(${mapState.scale})`;
                map.style.willChange = 'transform';
                
                // 更新滑动条
                updateZoomSlider();
            }
            
            // 更新缩放滑动条
            function updateZoomSlider() {
                const sliderFill = document.getElementById('zoom-slider-fill');
                const sliderThumb = document.getElementById('zoom-slider-thumb');
                const sliderContainer = document.querySelector('.zoom-slider-container');
                
                if (!sliderFill || !sliderThumb || !sliderContainer) return;
                
                // 计算滑动条高度比例
                const range = mapState.maxScale - mapState.minScale;
                const percent = (mapState.scale - mapState.minScale) / range;
                const height = sliderContainer.clientHeight;
                
                // 更新填充高度和滑块位置
                const fillHeight = percent * height;
                sliderFill.style.height = `${fillHeight}px`;
                sliderThumb.style.bottom = `${fillHeight}px`;
            }

            // 设置事件监听器
            function setupEventListeners() {
                // 鼠标拖动
                map.addEventListener('mousedown', startDrag);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', endDrag);
                
                // 触摸拖动
                map.addEventListener('touchstart', startDrag);
                document.addEventListener('touchmove', drag);
                document.addEventListener('touchend', endDrag);
                
                // 鼠标滚轮缩放 - 使用passive: false减少延迟
                mapContainer.addEventListener('wheel', zoom, { passive: false });
                
                // 缩放按钮
                zoomIn.addEventListener('click', () => zoomByButton(0.8));
                zoomOut.addEventListener('click', () => zoomByButton(-0.5));
                
                // 关闭弹窗
                popupClose.addEventListener('click', hidePopup);
                
                // 滑动条交互
                const sliderThumb = document.getElementById('zoom-slider-thumb');
                const sliderContainer = document.querySelector('.zoom-slider-container');
                
                if (sliderThumb && sliderContainer) {
                    let isDraggingSlider = false;
                    
                    // 滑动条点击
                    sliderContainer.addEventListener('click', function(e) {
                        const rect = sliderContainer.getBoundingClientRect();
                        const clickY = e.clientY - rect.top;
                        const height = rect.height;
                        const percent = 1 - (clickY / height);
                        
                        // 计算新的缩放比例
                        const range = mapState.maxScale - mapState.minScale;
                        const newScale = mapState.minScale + (percent * range);
                        
                        // 以屏幕中心为缩放点
                        const centerX = mapContainer.clientWidth / 2;
                        const centerY = mapContainer.clientHeight / 2;
                        
                        // 使用requestAnimationFrame确保平滑过渡
                        requestAnimationFrame(() => {
                            setZoomScale(newScale, centerX, centerY);
                            // 确保应用过渡效果
                            updateMapTransform(false);
                        });
                    });
                    
                    // 滑块拖动
                    sliderThumb.addEventListener('mousedown', function(e) {
                        e.stopPropagation();
                        isDraggingSlider = true;
                    });
                    
                    document.addEventListener('mousemove', function(e) {
                        if (!isDraggingSlider) return;
                        
                        const rect = sliderContainer.getBoundingClientRect();
                        const dragY = e.clientY - rect.top;
                        const height = rect.height;
                        let percent = 1 - (dragY / height);
                        
                        // 限制在0-1范围内
                        percent = Math.max(0, Math.min(1, percent));
                        
                        // 计算新的缩放比例
                        const range = mapState.maxScale - mapState.minScale;
                        const newScale = mapState.minScale + (percent * range);
                        
                        // 以屏幕中心为缩放点
                        const centerX = mapContainer.clientWidth / 2;
                        const centerY = mapContainer.clientHeight / 2;
                        
                        // 使用requestAnimationFrame确保平滑过渡
                        requestAnimationFrame(() => {
                            setZoomScale(newScale, centerX, centerY);
                            // 确保应用过渡效果
                            updateMapTransform(false);
                        });
                    });
                    
                    document.addEventListener('mouseup', function() {
                        isDraggingSlider = false;
                        // 确保拖动结束后应用过渡效果
                        updateMapTransform(false);
                    });
                }
                
                // 移动端双指缩放
                let lastTouchDistance = 0;
                mapContainer.addEventListener('touchstart', function(e) {
                    if (e.touches.length === 2) {
                        lastTouchDistance = getTouchDistance(e.touches);
                    }
                });
                
                mapContainer.addEventListener('touchmove', function(e) {
                    if (e.touches.length === 2) {
                        const currentDistance = getTouchDistance(e.touches);
                        const delta = currentDistance - lastTouchDistance;
                        
                        // 计算缩放因子
                        const zoomFactor = delta * 0.01;
                        
                        // 计算两个触摸点的中心作为缩放锚点
                        const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                        const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                        
                        // 以触摸点中心为锚点进行缩放
                        zoomByFactor(zoomFactor, centerX, centerY);
                        
                        lastTouchDistance = currentDistance;
                        e.preventDefault(); // 防止页面滚动
                    }
                }, { passive: false });
                
                // 窗口大小改变时重新计算
                window.addEventListener('resize', function() {
                    initMap();
                    updateAllIconPositions();
                });
            }
            
            // 直接设置缩放比例
            function setZoomScale(newScale, clientX, clientY) {
                // 限制在最小和最大缩放比例之间
                newScale = Math.max(mapState.minScale, Math.min(mapState.maxScale, newScale));
                
                // 如果缩放比例没有变化，则不进行操作
                if (newScale === mapState.scale) return;
                
                // 如果提供了缩放点，则以该点为中心进行缩放
                if (clientX !== undefined && clientY !== undefined) {
                    // 计算鼠标相对于地图原点的位置（考虑当前缩放和平移）
                    const mouseXRelToOrigin = (clientX - mapState.translateX) / mapState.scale;
                    const mouseYRelToOrigin = (clientY - mapState.translateY) / mapState.scale;
                    
                    // 计算新的平移量，使鼠标位置保持在同一点
                    mapState.translateX = clientX - mouseXRelToOrigin * newScale;
                    mapState.translateY = clientY - mouseYRelToOrigin * newScale;
                }
                
                // 更新缩放比例
                mapState.scale = newScale;
                
                // 应用变换，确保使用过渡效果
                updateMapTransform(false);
            }

            // 开始拖动
            function startDrag(e) {
                e.preventDefault();
                mapState.isDragging = true;
                map.classList.add('grabbing');
                
                // 拖动时自动关闭弹窗
                // hidePopup();
                
                if (e.type === 'mousedown') {
                    mapState.lastPosX = e.clientX;
                    mapState.lastPosY = e.clientY;
                } else if (e.type === 'touchstart' && e.touches.length === 1) {
                    mapState.lastPosX = e.touches[0].clientX;
                    mapState.lastPosY = e.touches[0].clientY;
                }
            }

            // 拖动中
            function drag(e) {
                if (!mapState.isDragging) return;
                e.preventDefault();
                
                let currentX, currentY;
                if (e.type === 'mousemove') {
                    currentX = e.clientX;
                    currentY = e.clientY;
                } else if (e.type === 'touchmove' && e.touches.length === 1) {
                    currentX = e.touches[0].clientX;
                    currentY = e.touches[0].clientY;
                } else {
                    return;
                }
                
                // 计算移动距离
                const deltaX = currentX - mapState.lastPosX;
                const deltaY = currentY - mapState.lastPosY;
                
                // 更新位置
                mapState.translateX += deltaX;
                mapState.translateY += deltaY;
                
                // 更新参考点
                mapState.lastPosX = currentX;
                mapState.lastPosY = currentY;
                
                // 应用变换
                updateMapTransform(true);
            }

            // 结束拖动
            function endDrag() {
                mapState.isDragging = false;
                map.classList.remove('grabbing');
                // 拖动结束后恢复过渡效果
                updateMapTransform(false);
            }

            // 鼠标滚轮缩放
            function zoom(e) {
                e.preventDefault();
                
                // 确定缩放方向和大小，使用适当的缩放因子
                const delta = -Math.sign(e.deltaY) * 0.2; // 增加缩放步长，使每次缩放更明显
                const newScale = mapState.scale * (1 + delta);
                
                // 使用requestAnimationFrame优化性能
                requestAnimationFrame(() => {
                    // 以鼠标位置为锚点进行缩放
                    setZoomScale(newScale, e.clientX, e.clientY);
                    // 确保应用过渡效果
                    updateMapTransform(false);
                });
            }

            // 按钮缩放
            function zoomByButton(delta) {
                // 以屏幕中心为缩放点
                const centerX = mapContainer.clientWidth / 2;
                const centerY = mapContainer.clientHeight / 2;
                const newScale = mapState.scale * (1 + delta);
                
                // 使用requestAnimationFrame优化性能
                requestAnimationFrame(() => {
                    setZoomScale(newScale, centerX, centerY);
                    // 确保应用过渡效果
                    updateMapTransform(false);
                });
            }

            // 按因子缩放 - 保留此函数以兼容现有代码，但内部使用setZoomScale
            function zoomByFactor(delta, clientX, clientY) {
                const newScale = mapState.scale * (1 + delta);
                setZoomScale(newScale, clientX, clientY);
            }

            // 计算两个触摸点之间的距离
            function getTouchDistance(touches) {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
        });
    </script>
</body>
</html>